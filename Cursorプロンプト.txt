# プロジェクト概要
Supabase Edge Functions で建築物検索用 API `/search` を作成してください。
入力は query パラメータ（文字列）、出力は JSON です。

#ディレクトリ構成イメージ
project_root/
├── index.php               # トップ・検索ページ
├── architect.php           # 建築家詳細ページ
├── building.php            # 建築物詳細ページ
├── db_connect.php          # DB接続共通
├── css/                    # CSSファイル
│   └── style.css
├── js/                     # JSファイル
│   └── main.js
├── images/                 # 画像など
└── .htaccess               # URLリライト用

物理ファイルは基本 index.php / architect.php / building.php の3つ
.htaccess でリライトしてフレンドリー URL を実現
/architects/tadao-ando/ → architect.php?slug=tadao-ando
/buildings/church-of-light/ → building.php?slug=church-of-light


# 検索仕様
- 対象テーブル: buildings_table_2, individual_architects, architect_compositions, building_architects
- 対象フィールド: title, titleEn, buildingTypes, buildingTypesEn, location, locationEn_from_datasheetChunkEn, name_ja, name_en
- 全角/半角スペースで区切った複数ワードを AND 検索
- websearch_to_tsquery('simple', query) を利用
- ts_rank によりスコア計算し、スコア順にソート
- 建築家配列 architects[] に全関与者を order_index 順で含める
  - individual_architects.name_ja, name_en, slug を含める

# レスポンス例
{
  "results": [
    {
      "building_id": 101,
      "slug": "osaka-prefectural-gymnasium",
      "title": "大阪府立体育会館",
      "titleEn": "Osaka Prefectural Gymnasium",
      "buildingTypes": "...",
      "buildingTypesEn": "...",
      "location": "...",
      "locationEn_from_datasheetChunkEn": "...",
      "completionYears": "2012",
      "lat": 34.401489,
      "lng": 132.454407,
      "architects": [
        {"name_ja": "安藤忠雄", "name_en": "Tadao Ando", "slug": "tadao-ando"},
        {"name_ja": "山田太郎", "name_en": "Taro Yamada", "slug": "taro-yamada"}
      ],
      "rank": 0.123
    }
  ],
  "pagination": {"limit": 10, "offset": 0, "total": 123}
}

# ページネーション
- limit と offset パラメータ対応

# フロント表示
- Google検索風のシンプルデザイン
- architects[] 配列はリンク付きで `/architects/{slug}` に誘導



# Edge Function 実装例（TypeScript）

functions/search/index.ts（例）

"""
import { serve } from "std/server";
import { createClient } from "@supabase/supabase-js";

// Supabase 環境変数
const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SUPABASE_ANON_KEY = Deno.env.get("SUPABASE_ANON_KEY")!;

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

serve(async (req) => {
  try {
    const url = new URL(req.url);
    const query = url.searchParams.get("query") || "";
    const limit = parseInt(url.searchParams.get("limit") || "10");
    const offset = parseInt(url.searchParams.get("offset") || "0");

    if (!query) {
      return new Response(JSON.stringify({ results: [], pagination: { limit, offset, total: 0 } }), {
        headers: { "Content-Type": "application/json" },
      });
    }

    // 検索ワードを tsquery に変換
    const words = query.replace(/\s+/g, " ").trim().split(" ");
    const tsQuery = words.map((w) => `${w}:*`).join(" & ");

    // SQL 実行
    const { data, error, count } = await supabase.rpc("search_buildings", {
      ts_query: tsQuery,
      limit,
      offset
    });

    if (error) throw error;

    return new Response(JSON.stringify({
      results: data,
      pagination: { limit, offset, total: count || 0 }
    }), {
      headers: { "Content-Type": "application/json" },
    });
  } catch (err: any) {
    return new Response(JSON.stringify({ error: err.message }), { status: 500 });
  }
});
"""


Supabase RPC 関数例（PostgreSQL）

"""
create or replace function search_buildings(ts_query text, limit int, offset int)
returns table(
  building_id int,
  slug text,
  title text,
  titleEn text,
  buildingTypes text,
  buildingTypesEn text,
  location text,
  locationEn_from_datasheetChunkEn text,
  architects json,
  rank float
) as $$
begin
  return query
  select
    b.building_id,
    b.slug,
    b.title,
    b."titleEn",
    b."buildingTypes",
    b."buildingTypesEn",
    b.location,
    b."locationEn_from_datasheetChunkEn",
    b."completionYears",
    b.lat,
    b.lng,
    (
      select json_agg(json_build_object('name_ja', ia.name_ja, 'name_en', ia.name_en, 'slug', ia.slug) order by ac.order_index)
      from building_architects ba
      join architect_compositions ac on ba.architect_id = ac.architect_id
      join individual_architects ia on ac.individual_architect_id = ia.individual_architect_id
      where ba.building_id = b.building_id
    ) as architects,
    ts_rank(to_tsvector('simple',
        coalesce(b.title,'') || ' ' || coalesce(b."titleEn",'') || ' ' ||
        coalesce(b."buildingTypes",'') || ' ' || coalesce(b."buildingTypesEn",'') || ' ' ||
        coalesce(b.location,'') || ' ' || coalesce(b."locationEn_from_datasheetChunkEn",'')
      ), to_tsquery('simple', ts_query)) as rank
  from buildings_table_2 b
  where to_tsvector('simple',
        coalesce(b.title,'') || ' ' || coalesce(b."titleEn",'') || ' ' ||
        coalesce(b."buildingTypes",'') || ' ' || coalesce(b."buildingTypesEn",'') || ' ' ||
        coalesce(b.location,'') || ' ' || coalesce(b."locationEn_from_datasheetChunkEn",'')
      ) @@ to_tsquery('simple', ts_query)
  order by rank desc
  limit limit offset offset;
end;
$$ language plpgsql;
"""